function verifierErreurs() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var articlesSheet = ss.getSheetByName("ARTICLES");
  var erreursSheet = ss.getSheetByName("SUIVI_ERREURS");
  erreursSheet.clearContents();
  
  var nbCols = 10;
  var lastRow = articlesSheet.getLastRow();
  if (lastRow < 2) return;
  
  var data = articlesSheet.getRange(1, 1, lastRow, nbCols).getValues();
  var headers = data[0];
  var output = [headers.concat(["Erreur"])];
  
  var params = getParametres();
  var reglesArticles = params.reglesArticles; // tableau d'objets { article, annees: [] }
  var checkDuplicates = params.checkDuplicates;
  var checkCDPConflict = params.checkCDPConflict;
  var debug = params.debugActif;
  
  // Fonction de normalisation pour comparer de manière cohérente
  function normalize(str) {
    return str ? str.trim().toLowerCase() : "";
  }
  
  // Pré-calculer le mapping des règles avec des clés normalisées
  var mappingRules = {};
  for (var j = 0; j < reglesArticles.length; j++) {
    var rule = reglesArticles[j];
    mappingRules[normalize(rule.article)] = rule.annees;
  }
  
  if (debug) {
    Logger.log("=== Paramètres chargés ===");
    Logger.log("checkDuplicates: " + checkDuplicates + ", checkCDPConflict: " + checkCDPConflict);
    Logger.log("mappingRules: " + JSON.stringify(mappingRules));
  }
  
  var rowsInfo = [];
  var groupByPassport = {};
  
  // Boucle sur toutes les lignes (à partir de la 2? ligne)
  for (var i = 1; i < data.length; i++) {
    var row = data[i];
    var status = row[9] ? row[9].toString().trim() : "";
    if (status === "Annulé") continue;
    
    var passport = row[0] ? row[0].toString().trim() : "";
    var dateNaissance = row[3];
    var nomFrais = row[5] ? row[5].toString() : "";
    var normArticle = normalize(nomFrais);
    
    if (!mappingRules.hasOwnProperty(normArticle)) {
      if (debug) Logger.log("Article [" + nomFrais + "] non trouvé dans mappingRules => ligne ignorée");
      continue;
    }
    
    var annee;
    if (dateNaissance instanceof Date) {
      annee = dateNaissance.getFullYear();
    } else {
      var parts = dateNaissance.toString().split(/[-\/]/);
      annee = parseInt(parts[parts.length - 1], 10);
    }
    if (debug) Logger.log("Ligne " + (i+1) + " | Passport: " + passport + " | Article: " + nomFrais + " | Année: " + annee);
    
    var allowedYears = mappingRules[normArticle];
    var valid = false;
    for (var k = 0; k < allowedYears.length; k++) {
      if (allowedYears[k] === annee) { valid = true; break; }
    }
    var errors = [];
    if (!valid) {
      errors.push("Année de naissance non valide pour " + nomFrais + " (attendu: " + allowedYears.join(", ") + ")");
      if (debug) Logger.log("Erreur d'année pour " + nomFrais + ": " + annee);
    }
    
    var info = {
      row: row,
      passport: passport,
      nomFrais: nomFrais,
      normArticle: normArticle,
      errors: errors
    };
    rowsInfo.push(info);
    
    if (!groupByPassport[passport]) {
      groupByPassport[passport] = [];
    }
    groupByPassport[passport].push(info);
  }
  
  // Gestion des doublons et conflit CDP par membre
  for (var passport in groupByPassport) {
    var group = groupByPassport[passport];
    var countArticles = {};
    // Compter les occurrences de chaque article (normalisé)
    for (var m = 0; m < group.length; m++) {
      var norm = group[m].normArticle;
      countArticles[norm] = (countArticles[norm] || 0) + 1;
    }
    
    // Détection des doublons
    if (checkDuplicates) {
      for (var norm in countArticles) {
        if (countArticles[norm] > 1) {
          for (var m = 0; m < group.length; m++) {
            if (group[m].normArticle === norm) {
              var msgDup = "Article '" + group[m].nomFrais + "' est en doublon pour ce membre";
              if (group[m].errors.indexOf(msgDup) === -1) {
                group[m].errors.push(msgDup);
              }
            }
          }
          if (debug) Logger.log("Doublon détecté pour passport=" + passport + " article=" + norm);
        }
      }
    }
    
    // Détection du conflit CDP
    if (checkCDPConflict) {
      var key1 = normalize("1 entraînement CDP par semaine (U9 à U12)");
      var key2 = normalize("2 entraînements CDP par semaine (U9 à U12)");
      var has1 = false, has2 = false;
      for (var m = 0; m < group.length; m++) {
        if (group[m].normArticle === key1) has1 = true;
        if (group[m].normArticle === key2) has2 = true;
      }
      if (has1 && has2) {
        for (var m = 0; m < group.length; m++) {
          if (group[m].normArticle === key1 || group[m].normArticle === key2) {
            var msgConflict = "Choix multiple pour entraînement CDP : veuillez choisir soit 1, soit 2 CDP";
            if (group[m].errors.indexOf(msgConflict) === -1) {
              group[m].errors.push(msgConflict);
            }
          }
        }
        if (debug) Logger.log("Conflit CDP détecté pour passport=" + passport);
      }
    }
  }
  
  // Consolidation des erreurs par membre+article
  var consolidated = {};
  for (var n = 0; n < rowsInfo.length; n++) {
    var info = rowsInfo[n];
    if (info.errors.length > 0) {
      var key = info.passport + "|" + info.nomFrais;
      if (!consolidated.hasOwnProperty(key)) {
        consolidated[key] = { row: info.row, errors: info.errors.slice() };
      } else {
        for (var p = 0; p < info.errors.length; p++) {
          var err = info.errors[p];
          if (consolidated[key].errors.indexOf(err) === -1) {
            consolidated[key].errors.push(err);
          }
        }
      }
    }
  }
  
  for (var key in consolidated) {
    var entry = consolidated[key];
    output.push(entry.row.concat([entry.errors.join(" / ")]));
  }
  
  if (output.length > 1) {
    erreursSheet.getRange(1, 1, output.length, nbCols + 1).setValues(output);
  } else {
    erreursSheet.getRange(1, 1, 1, nbCols + 1).setValues(output);
  }
  
  var numRows = output.length;
  if (numRows > 1) {
    erreursSheet.getRange(2, 1, numRows - 1, 1).setNumberFormat("@");
  }
  
  var errorCount = output.length - 1;
  SpreadsheetApp.getUi().alert("Script terminé. Nombre d'erreurs trouvées : " + errorCount);
  ss.setActiveSheet(erreursSheet);
}
